{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"aboutME","text":"haahhahahah","link":"/aboutME/index.html"}],"posts":[{"title":"GitHub + Jenkins + Docker 自动构建","text":"由于每次更新博客部署起来太麻烦，心想可以自己搭建一套属于自己的devop环境，刚好之前也有接触过，但是没有自己亲手搭建，刚好自己有这个需求。 什么是DEVOPSDocker安装Jenkins配置GitHub配置 hr{ margin: 40px 0; height: 3px; border: none; background-color: #ddd; background-image: repeating-linear-gradient(-45deg, #fff, #fff 4px, transparent 4px, transparent 8px); } p{ margin: 0 0 25px 0; font-size: 14px; line-height: 3; text-indent:20px; text-align: justify; /*letter-spacing:1px;*/ }","link":"/2019/02/15/devops/"},{"title":"感谢","text":"感谢crossoverjie,yemengying两位大佬，无意间看到他们的Blog萌生了自己搭建一套自己博客的想法,开始记录自己用到的一些技术和生活。 hr{ margin: 40px 0; height: 3px; border: none; background-color: #ddd; background-image: repeating-linear-gradient(-45deg, #fff, #fff 4px, transparent 4px, transparent 8px); } p{ margin: 0 0 25px 0; font-size: 14px; line-height: 3; text-indent:20px; text-align: justify; /*letter-spacing:1px;*/ }","link":"/2019/01/01/begin/"},{"title":"Namesilo + CloudFlare配置Https服务","text":"搭建博客过程中我在NameSilo上购买了域名自己人生当中的第一个域名（rulinzi.com），然后将域名解析到我的服务器ip（配置解析后有延迟，我的大概只过了几分钟就生效了），然后采用CloudFlare免费上了Https，记录一下遇到的问题. 域名(NameSilo) 为了便于记忆简单，人们采用域名的方式代替ip，由此产生了域名解析。类型:A ,AAAA , CNAME , MX , TXT/SPF , SRV , CAA记录解析。 A记录解析：A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名 CNAME记录：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就http://www.mydomain.com/和mail.mydomain.com。实际上他们都指向host.mydomain.com。 关于如何在NameSilo配置域名 SSL(cloudflare)关于如何使用cloudflare加SSL hr{ margin: 40px 0; height: 3px; border: none; background-color: #ddd; background-image: repeating-linear-gradient(-45deg, #fff, #fff 4px, transparent 4px, transparent 8px); } p{ margin: 0 0 25px 0; font-size: 14px; line-height: 3; text-indent:20px; text-align: justify; /*letter-spacing:1px;*/ }","link":"/2019/02/11/servers/"},{"title":"Kurento简介","text":"Kurento是一个WebRTC媒体服务器，同时提供了一系列的客户端API，可以简化供浏览器、移动平台使用的视频类应用程序的开发。Kurento支持：群组通信（group communications）媒体流的转码（transcoding）、录制（recording）、广播（broadcasting）、路由（routing）高级媒体处理特性，包括：机器视觉（CV）、视频索引、增强现实（AR）、语音分析Kurento的模块化架构使其与第三方媒体处理算法 —— 语音识别、人脸识别 —— 很容易集成。 架构和大部分多媒体通信技术一样，Kurento应用的整体架构包含两个层（layer）或者叫平面（plane）： 信号平面（Signaling Plane）：负责通信的管理，例如媒体协商、QoS、呼叫建立、身份验证等 媒体平面（Media Plane）：负责媒体传输、编解码等 典型Kurento应用的整体架构如下图： 分层视角按分层的方式来划分，Kurento应用可以分为三层（类似于典型的Web应用）： 展现层 —— 浏览器、移动应用、其它媒体源等应用客户端： 基于任意协议和应用逻辑层通信，发起信号处理 基于RTP/HTTP/WebRTC协议和KMS通信： 通过KMS的输入端点，传输媒体流到KMS 通过KMS的输出端点，从KMS获得媒体流 应用逻辑层——应用服务器负责信号平面： 基于WebSocket/HTTP/REST/SIP等方式和应用客户端通信，进行信号处理 内嵌Kurento Client，基于Kurento Protocol与KMS通信，管理媒体元素/媒体管线 服务层——KMS负责媒体平面，可以对输入流进行各种处理，并产生输出流 层之间的交互媒体协商（信号处理）阶段： 客户端首先向应服务器请求某种媒体特性（例如请求一个九画面视频监控流、请求发布自己的SDP）。这块WebRTC没有规定，可以基于任何协议（HTTP/WS/SIP）实现 应用服务器接收到请求后，执行特定的服务器端逻辑，例如AAA（认证授权审计）、CDR生成等 应用服务器处理请求，并命令KMS实例化适当的媒体元素、构建媒体流（例如从多个RTSP源混合出九画面） 媒体流构建完毕后，KMS应答应用服务器，后者应答客户端，告知其如何获取媒体服务 媒体交换阶段： 客户端利用协商阶段收集的信息，向KMS发起请求（例如向目标端口发起UDP请求，获取九画面视频监控流） 下图是交互的序列示意，注意先后顺序： WebRTC应用的例子Kurento允许基于WebRTC建立浏览器和KMS之间的实时多媒体会话： 客户端基于SDP来发布自己的媒体特性，请求发送给应用服务器 应用服务器根据SDP来创建合适的WebRTC端点，并请求KMS生成一个响应SDP 应用服务器获得响应SDP后，将其返回给客户端 由于双方都知道对方的SDP了，客户端和KMS可以进行媒体交换了 下图是交互的序列示意： Kurento也可以作为一个媒体代理，让浏览器之间建立直接的媒体交换。交互序列仍然如上图，仅仅是KMS返回的SDP不同 媒体服务器WebRTC让浏览器能够进行实时的点对点通信（在没有服务器的情况下）。但是要想实现群组通信、媒体流录制、媒体广播、转码等高级特性，没有媒体服务器是很难实现的。 Kurento的核心是一个媒体服务器（Kurento Media Server，KMS），负责媒体的传输、处理、加载、录制，主要基于 GStreamer实现。此媒体服务器的特性包括： 网络流协议处理，包括HTTP、RTP、WebRTC 支持媒体混合（mixing）、路由和分发的群组通信（MCU、SFU功能） 对机器视觉和增强现实过滤器的一般性支持 媒体存储支持，支持对WebM、MP4进行录像操作，可以播放任何GStreamer支持的视频格式 对于GStreamer支持的编码格式，可以进行任意的转码，例如VP8, H.264, H.263, AMR, OPUS, Speex, G.711 模块KMS基于模块化的设计，模块主要分为三类： 核心（kms-core） 媒体元素（kms-elements） 过滤器（kms-filters） 其它增强KMS的模块，例如kms-crowddetector, kms-pointerdetector, kms-chroma, kms-platedetector KMS允许用户扩展自己的模块。 协议Kurento Protocol是一个网络协议，通过WebSocket暴露KMS的特性。 Kurento API是对上述协议的OO封装，通过此API能够创建媒体元素和管线。Kurento提供了API的Java、JavaScript绑定。 ###客户端 Kurento提供了Java、JavaScript（包括浏览器和Node.js）的客户端库，通过这些库你可以控制媒体服务器。对于其它编程语言，可以使用 Kurento Protocol协议（基于WebSocket/JSON-RPC）。 Kurento客户端API基于所谓媒体元素（Media Element）的概念。一个每天元素持有一种特定的媒体特性。例如： 媒体元素WebRtcEndpoint的特性是，接收WebRTC媒体流 媒体元素RecorderEndpoint的特性是，将接收到的媒体流录制到文件系统 媒体元素FaceOverlayFilter则能够检测人脸，在其上方显示一个特定的图像开箱即用的媒体元素如下图： 从开发者角度来说，操控媒体元素就好像搭积木。 你只需要按照期望的拓扑结构把它们连接起来就可以了。一系列连接起来的媒体元素称为媒体管线（Media Pipeline）。只有一个管线内部的媒体元素才能相互通信 当创建管道时，开发者需要明确希望使用到的特性，以及媒体连接（connectivity） 产生媒体的元素和消费媒体的元素之间的连接： 1234sourceMediaElement.connect(sinkMediaElement);// 例如：客户端接收WebRTC流并录制到媒体服务器的文件系统webRtcEndpoint.connect(recorderEndpoint); Web客户端为了简化浏览器客户端的WebRTC流处理，Kurento提供了工具WebRtcPeer，你仍然可以使用WebRTC的标准API，以及连接到WebRtcEndpoint。","link":"/2019/04/02/kurento/"}],"tags":[{"name":"server","slug":"server","link":"/tags/server/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"WebRTC","slug":"WebRTC","link":"/tags/WebRTC/"},{"name":"Thanks","slug":"Thanks","link":"/tags/Thanks/"},{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"}],"categories":[]}